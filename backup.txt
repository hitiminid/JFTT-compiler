%{
  // code
  // #include <stdio.h>
  // #include <stdlib.h>
  #include <cstdlib>
  #include <iostream>

  #include <string>
  #include <map>
  #include <vector>
  #include <stdio.h>
  #include <stdlib.h>

  extern "C" int yylex();
  extern "C" int yyparse();

  // variables
  /*===================================================*/
  /*                      CONSTANTS                    */
  /*===================================================*/

  #define NUMBER_OF_RESERVED_MEMORY_INDEXES 9
  #define ERROR_BUFFER 150

  /*===================================================*/
  /*                      VARIABLES                    */
  /*===================================================*/
  int currentMemoryIndex = NUMBER_OF_RESERVED_MEMORY_INDEXES;

  /*===================================================*/
  /*                     STRUCTURES                    */
  /*===================================================*/


  int accumulator;
  char errorMessage[ERROR_BUFFER];


  /*vector containing commands*/
	std::vector<std::string> commandsVector;

  /* declaredVariables */
  /* (name :: string, adress :: int) */
  /* (name :: string, pair of pointer and memory adress :: int) */
  std::map<std::string, int> variablesMap;

  /* each initialized variable */
  /* (name :: string, isInitialized :: boolean) */
  std::map<std::string, bool> initializedVariablesMap;

  /* each array's size */
  /* if a variable is in here then it's an array - useful when determining type of a data*/
  /* (name :: string, arraySize :: int) */
  std::map<std::string, int> arraysMap;


  // int yylex();
  void yyerror (char* msg);

  /*===================================================*/
  /*                      FUNCTIONS                    */
  /*===================================================*/

  // used for declaring a variable
  void declareAVariable(std::string name);
  // used for declaring an array
  void declareAnArray(std::string name, int arraySize);

  // function used for determining whether variable is declared
  bool isVariableDeclared(std::map<std::string, int> *mapToSearch, std::string name);

  bool isVariableInitialized(std::map<std::string, bool>* initializedMap, std::string variableName);

  // debug function performed at the end of parsing
  void finish();

  void displayMap(std::map<std::string, int>* mapToDisplay);
  void displayInitializedMap(std::map<std::string, bool>* map);
  void displayCommandVector(std::vector<std::string>* commandsVector);

  void showAllocatedMemoryIndexes();

  void pushCodeWithAddress(std::string opCode, int number);
  void pushCode(std::string opCode);


  void generateNumber(std::string);

%}

%union {
    char* string;
    int   num;
}

// program structure
%token VAR BEG END
// control statements
%token IF THEN ELSE ENDIF
//while loop
%token WHILE DO ENDWHILE
// for loop
%token FOR FROM TO ENDFOR DOWNTO
// IO
%token READ WRITE
// compare statements
%token ASSGN EQ NEQ GT GE LT LE
// operations
%token ADD SUB MUL DIV MOD
// numbers and variables
%token <string> num
%token <string> PID
%token SEM
// right and left brackets used for arrays
%token LEFT_BR RIGHT_BR


%left '-' '+'
%left '*' '/'
// where is modulo ???
%right '^' // do I need it?

%%

program         : VAR {/*showAllocatedMemoryIndexes();*/} vdeclarations BEG commands END {
                  finish();
                }

vdeclarations   : vdeclarations  PID {
                  declareAVariable($2);
                }

                | vdeclarations  PID LEFT_BR num RIGHT_BR {
                  int arraySize = atoi($4);
                  declareAnArray($2, arraySize);
                }
                | {
                  // std::cout << "No variables declared" << "\n";
                }
;

commands     : commands  command { }
             | command           { }
;

command      : identifier  ASSGN  expression SEM {
                std::string variableName = $<string>1;

                if (!isVariableDeclared(&variablesMap, variableName)) { //variable is not declared
                  std::cout << "Error [line "<< "]: Variable "<< $<string>1 <<" not declared!" << "\n";
                  exit(1);
                } else { // variable is declared
                  // find an adress
                  int variableAddress = variablesMap[variableName];
                  // set as initialized
                  initializedVariablesMap[variableName] = true;
                  //
                  pushCodeWithAddress("STORE", variableAddress);
                }
             }
             | IF  condition THEN  commands ELSE  commands  ENDIF {}
             | IF  condition  THEN  commands  ENDIF
             | WHILE  condition  DO  commands  ENDWHILE
             | FOR  PID  FROM  value TO  value DO  commands  ENDFOR
             | FOR  PID  FROM  value  DOWNTO  value DO  commands  ENDFOR
             | READ  identifier SEM {
               /*todo: doesn't work*/
               std::string variableName = $<string>2;
               if (!isVariableDeclared(&variablesMap, variableName)) { //variable is not declared
                 std::cout << "Error [line "<< "]: Variable "<< $<string>2 <<" not declared!" << "\n";
                 exit(1);
               } else {
                 int variableAddress = variablesMap[variableName];
                //  pushCodeWithAddress("STORE", variableAddress);
                 pushCode("GET");
                 if (isVariableDeclared(&arraysMap, variableName)) {
                   std::cout << "I'm an array!" << "\n";
                 } else {
                   int variableAddress = variablesMap[variableName];
                   std::cout << "I'm a variable, with adress : "<< variableAddress <<"\n";
                 }
               }
             }
             | WRITE value SEM {
               std::string variableName = $<string>2;
               std::cout << "hello my name is: " << variableName << "\n";
               displayInitializedMap(&initializedVariablesMap);
               //std::cout << "hello there\n";
               pushCode("++++ WRITE START ++++");

               if (isVariableDeclared(&variablesMap, variableName)) {
                 // at this point we know that variable is declared, what about being initialized?
                 int variableAddress = variablesMap[variableName];
                 //std::cout << "hello there 2 \n";
                 std::cout << "checking if " << variableName << " is initialized\n";
                 //if (!isVariableDeclared(&initializedVariablesMap, variableName)) { //checking if it's initialized
                 if (!isVariableInitialized(&initializedVariablesMap, variableName)) { //checking if it's initialized
                  std::cout << "Variable " << variableName << " not initialized\n";
                } else {
                  std::cout << variableName << " is initialized\n"; //wrong message,
                  //  pushCodeWithAddress("STORE", variableAddress);
                  if (isVariableDeclared(&arraysMap, variableName)) {
                    std::cout << "I'm an array!" << "\n";
                    std::cout << "Yet not implemented\n";

                  } else {
                    // variable is declared and initialized
                    //todo: find a way to determine type
                    // if it's a number
                    // if it's a variable
                    // int variableAddress = variablesMap[variableName];
                    pushCode("ZERO");
                    pushCodeWithAddress("LOAD", variableAddress);
                    pushCode("PUT");
                    // if it's an array
                  }
                }
               } else { //variable is not declared
                 std::cout << "Error [line "<< "]: Variable "<< $<string>2 <<" not declared!" << "\n";
                 exit(1);
               }
             }
;
expression   : value {
                /*
                if it's a number then load it directly to the accumulator
                otherwise find an adress and THEN load it
                */
                pushCodeWithAddress("LOAD", 123);
              }
             | value ADD value { }
             | value SUB value { }
             | value MUL value { }
             | value DIV value { }
             | value MOD value { }
;
condition    : value EQ value  { }
             | value NEQ value { }
             | value LT  value { }
             | value GT  value { }
             | value LE  value { }
             | value GE  value { }
;
value        : num {
                generateNumber($1);
             }
             | identifier {
               std::string variableName = $<string>1;
               if (!isVariableDeclared(&variablesMap, variableName)) {
                 // not declared
                  std::cout << "variable " << variableName << " NOT \n";
               } else {
                 // variable is declared
                 // if(!isVariableDeclared(&initializedVariablesMap, variableName)) {
                 if(!isVariableInitialized(&initializedVariablesMap, variableName)) {
                  std::cout << "Variable " << variableName << " declared but not initialized\n";
                  exit(1);
                } else {
                  // and initialized
                  std::cout << "variable " << variableName << " YES \n";
                }
               }
             }
;
identifier   : PID
             | PID LEFT_BR PID RIGHT_BR

%{
  // code
  // #include <stdio.h>
  // #include <stdlib.h>
  #include <cstdlib>
  #include <iostream>

  #include <string>
  #include <map>
  #include <vector>
  #include <stdio.h>
  #include <stdlib.h>

  extern "C" int yylex();
  extern "C" int yyparse();

  // variables
  /*===================================================*/
  /*                      CONSTANTS                    */
  /*===================================================*/

  #define NUMBER_OF_RESERVED_MEMORY_INDEXES 9
  #define ERROR_BUFFER 150

  /*===================================================*/
  /*                      VARIABLES                    */
  /*===================================================*/
  int currentMemoryIndex = NUMBER_OF_RESERVED_MEMORY_INDEXES;

  /*===================================================*/
  /*                     STRUCTURES                    */
  /*===================================================*/


  int accumulator;
  char errorMessage[ERROR_BUFFER];


  /*vector containing commands*/
	std::vector<std::string> commandsVector;

  /* declaredVariables */
  /* (name :: string, adress :: int) */
  /* (name :: string, pair of pointer and memory adress :: int) */
  std::map<std::string, int> variablesMap;

  /* each initialized variable */
  /* (name :: string, isInitialized :: boolean) */
  std::map<std::string, bool> initializedVariablesMap;

  /* each array's size */
  /* if a variable is in here then it's an array - useful when determining type of a data*/
  /* (name :: string, arraySize :: int) */
  std::map<std::string, int> arraysMap;


  // int yylex();
  void yyerror (char* msg);

  /*===================================================*/
  /*                      FUNCTIONS                    */
  /*===================================================*/

  // used for declaring a variable
  void declareAVariable(std::string name);
  // used for declaring an array
  void declareAnArray(std::string name, int arraySize);

  // function used for determining whether variable is declared
  bool isVariableDeclared(std::map<std::string, int> *mapToSearch, std::string name);

  bool isVariableInitialized(std::map<std::string, bool>* initializedMap, std::string variableName);

  // debug function performed at the end of parsing
  void finish();

  void displayMap(std::map<std::string, int>* mapToDisplay);
  void displayInitializedMap(std::map<std::string, bool>* map);
  void displayCommandVector(std::vector<std::string>* commandsVector);

  void showAllocatedMemoryIndexes();

  void pushCodeWithAddress(std::string opCode, int number);
  void pushCode(std::string opCode);


  void generateNumber(std::string);

%}

%union {
    char* string;
    int   num;
}

// program structure
%token VAR BEG END
// control statements
%token IF THEN ELSE ENDIF
//while loop
%token WHILE DO ENDWHILE
// for loop
%token FOR FROM TO ENDFOR DOWNTO
// IO
%token READ WRITE
// compare statements
%token ASSGN EQ NEQ GT GE LT LE
// operations
%token ADD SUB MUL DIV MOD
// numbers and variables
%token <string> num
%token <string> PID
%token SEM
// right and left brackets used for arrays
%token LEFT_BR RIGHT_BR


%left '-' '+'
%left '*' '/'
// where is modulo ???
%right '^' // do I need it?

%%

program         : VAR {/*showAllocatedMemoryIndexes();*/} vdeclarations BEG commands END {
                  finish();
                }

vdeclarations   : vdeclarations  PID {
                  declareAVariable($2);
                }

                | vdeclarations  PID LEFT_BR num RIGHT_BR {
                  int arraySize = atoi($4);
                  declareAnArray($2, arraySize);
                }
                | {
                  // std::cout << "No variables declared" << "\n";
                }
;

commands     : commands  command { }
             | command           { }
;

command      : identifier  ASSGN  expression SEM {
                std::string variableName = $<string>1;

                if (!isVariableDeclared(&variablesMap, variableName)) { //variable is not declared
                  std::cout << "Error [line "<< "]: Variable "<< $<string>1 <<" not declared!" << "\n";
                  exit(1);
                } else { // variable is declared
                  // find an adress
                  int variableAddress = variablesMap[variableName];
                  // set as initialized
                  initializedVariablesMap[variableName] = true;
                  //
                  pushCodeWithAddress("STORE", variableAddress);
                }
             }
             | IF  condition THEN  commands ELSE  commands  ENDIF {}
             | IF  condition  THEN  commands  ENDIF
             | WHILE  condition  DO  commands  ENDWHILE
             | FOR  PID  FROM  value TO  value DO  commands  ENDFOR
             | FOR  PID  FROM  value  DOWNTO  value DO  commands  ENDFOR
             | READ  identifier SEM {
               /*todo: doesn't work*/
               std::string variableName = $<string>2;
               if (!isVariableDeclared(&variablesMap, variableName)) { //variable is not declared
                 std::cout << "Error [line "<< "]: Variable "<< $<string>2 <<" not declared!" << "\n";
                 exit(1);
               } else {
                 int variableAddress = variablesMap[variableName];
                //  pushCodeWithAddress("STORE", variableAddress);
                 pushCode("GET");
                 if (isVariableDeclared(&arraysMap, variableName)) {
                   std::cout << "I'm an array!" << "\n";
                 } else {
                   int variableAddress = variablesMap[variableName];
                   std::cout << "I'm a variable, with adress : "<< variableAddress <<"\n";
                 }
               }
             }
             | WRITE value SEM {
               std::string variableName = $<string>2;
               std::cout << "hello my name is: " << variableName << "\n";
               displayInitializedMap(&initializedVariablesMap);
               //std::cout << "hello there\n";
               pushCode("++++ WRITE START ++++");

               if (isVariableDeclared(&variablesMap, variableName)) { // at this point we know that variable is declared, what about being initialized?

                 int variableAddress = variablesMap[variableName];
                 //std::cout << "hello there 2 \n";
                 std::cout << "checking if " << variableName << " is initialized\n";
                 //if (!isVariableDeclared(&initializedVariablesMap, variableName)) { //checking if it's initialized
                 if (!isVariableInitialized(&initializedVariablesMap, variableName)) { //checking if it's initialized
                  std::cout << "Variable " << variableName << " not initialized\n";
                } else {
                  std::cout << variableName << " is initialized\n"; //wrong message,
                  //  pushCodeWithAddress("STORE", variableAddress);
                  if (isVariableDeclared(&arraysMap, variableName)) {
                    std::cout << "I'm an array!" << "\n";
                    std::cout << "Yet not implemented\n";

                  } else {
                    // variable is declared and initialized
                    //todo: find a way to determine type
                    // if it's a number
                    // if it's a variable
                    // int variableAddress = variablesMap[variableName];
                    pushCode("ZERO");
                    pushCodeWithAddress("LOAD", variableAddress);
                    pushCode("PUT");
                    // if it's an array
                  }
                }
               } else { //variable is not declared
                 std::cout << "Error [line "<< "]: Variable "<< $<string>2 <<" not declared!" << "\n";
                 exit(1);
               }
             }
;
expression   : value {
                /*
                if it's a number then load it directly to the accumulator
                otherwise find an adress and THEN load it
                */
                pushCodeWithAddress("LOAD", 123);
              }
             | value ADD value { }
             | value SUB value { }
             | value MUL value { }
             | value DIV value { }
             | value MOD value { }
;
condition    : value EQ value  { }
             | value NEQ value { }
             | value LT  value { }
             | value GT  value { }
             | value LE  value { }
             | value GE  value { }
;
value        : num {
                generateNumber($1);
             }
             | identifier {
               std::string variableName = $<string>1;
               if (!isVariableDeclared(&variablesMap, variableName)) {
                 // not declared
                  std::cout << "variable " << variableName << " NOT \n";
               } else {
                 // variable is declared
                 // if(!isVariableDeclared(&initializedVariablesMap, variableName)) {
                 if(!isVariableInitialized(&initializedVariablesMap, variableName)) {
                  std::cout << "Variable " << variableName << " declared but not initialized\n";
                  exit(1);
                } else {
                  // and initialized
                  std::cout << "variable " << variableName << " YES \n";
                }
               }
             }
;
identifier   : PID
             | PID LEFT_BR PID RIGHT_BR
             | PID LEFT_BR num RIGHT_BR
;
%%

void declareAVariable(std::string name) {
  if (!isVariableDeclared(&variablesMap, name)) {
    currentMemoryIndex++;
    variablesMap[name] = currentMemoryIndex;
    initializedVariablesMap[name] = false;
    std::cout << "Declaring new variable: " << name << " with adress: " << currentMemoryIndex << "\n";
  } else {
    //throw an error
    std::cout << "Variable " << name << " already defined!" << "\n";
    exit(1);
    //snprintf(errorMessage, ERROR_BUFFER, "Variable '%s' already defined.", name);
    //yyerror(errorMessage);
  }
}

void displayArraySizesMap(std::map<std::string, int>* arraySizesMap) {
  for(auto elem : *arraySizesMap) {
     std::cout << elem.first << " " << elem.second << "\n";
  }
}

void declareAnArray(std::string name, int arraySize) {
  if (!isVariableDeclared(&variablesMap, name)) {

    currentMemoryIndex++;
    std::cout << "Declaring new array '" << name << "' of size: " << arraySize << " starting at memIndex " << currentMemoryIndex;

    variablesMap[name] = currentMemoryIndex; // the beggining of an array
    initializedVariablesMap[name] = true;
    arraysMap[name] = arraySize;
    currentMemoryIndex += arraySize - 1; //without the first one
    displayArraySizesMap(&arraysMap);
    std::cout << " and ending at " << currentMemoryIndex << "\n";
  } else {
    std::cout << "Array " << name << " already defined!" << "\n";
  }
}

bool isVariableDeclared(std::map<std::string, int> *mapToSearch, std::string name) {
  if ( (*mapToSearch).find(name) == (*mapToSearch).end() ) {
    // not found
    return false;
  } else {
    // found
    return true;
  }
}

void showAllocatedMemoryIndexes() {
  for (int i = 0; i < 10; i++) {
    std::cout << "index: " << i << " allocated for computing variables\n";
  }
  std::cout << "###################\n\n\n\n";
}

void finish() {
  //std::cout << "number of variables + tokens = " << variablesMap.size() << "\n";
  // displayMap(&variablesMap);
  pushCode("HALT");
  displayCommandVector(&commandsVector);
}

void displayMap(std::map<std::string, int>* mapToDisplay) {
  for(auto elem : *mapToDisplay) {
     std::cout << elem.first << " " << elem.second << "\n";
  }
}

void displayInitializedMap(std::map<std::string, bool>* map) {
  for(auto elem : *map) {
     std::cout << elem.first << " " << elem.second << "\n";
  }
}

bool isVariableInitialized(std::map<std::string, bool>* initializedMap, std::string variableName) {
  // mozna w sumie przerobic
  if ( (*initializedMap).find(variableName) == (*initializedMap).end() ) { // not found
    return false;
  } else { // found
    if ((*initializedMap)[variableName] == true) { //initialized
      return true;
    } else { // not initialized
      return false;
    }
  }
}

void displayCommandVector(std::vector<std::string> *commands) {
  int vectorSize = commands->size();
  for (int i=0; i < vectorSize; i++) {
    std::cout << commands->at(i) << "\n";
  }
}

/*===================================================*/
/*                 GENERATING CODE                   */
/*===================================================*/

void pushCode(std::string opCode) {
  commandsVector.push_back(opCode);
}

void pushCodeWithAddress(std::string opCode, int number) {
  std::string space = " ";
  std::string whole = opCode + space + std::to_string(number);
  commandsVector.push_back(whole);
}

void generateNumber(std::string number) {
  std::string space = " ";
  std::string whole = "GENERATING NUMBER:" + space + number;
  commandsVector.push_back(whole);
}

/*===================================================*/
/*                     STRUCTURES                    */
/*===================================================*/

void freeAll() {

}

int main() {
  yyparse();
  return 0;
}

void yyerror (char *msg) {
    printf("ERROR\n");
}

             | PID LEFT_BR num RIGHT_BR
;
%%

void declareAVariable(std::string name) {
  if (!isVariableDeclared(&variablesMap, name)) {
    currentMemoryIndex++;
    variablesMap[name] = currentMemoryIndex;
    initializedVariablesMap[name] = false;
    std::cout << "Declaring new variable: " << name << " with adress: " << currentMemoryIndex << "\n";
  } else {
    //throw an error
    std::cout << "Variable " << name << " already defined!" << "\n";
    exit(1);
    //snprintf(errorMessage, ERROR_BUFFER, "Variable '%s' already defined.", name);
    //yyerror(errorMessage);
  }
}

void displayArraySizesMap(std::map<std::string, int>* arraySizesMap) {
  for(auto elem : *arraySizesMap) {
     std::cout << elem.first << " " << elem.second << "\n";
  }
}

void declareAnArray(std::string name, int arraySize) {
  if (!isVariableDeclared(&variablesMap, name)) {

    currentMemoryIndex++;
    std::cout << "Declaring new array '" << name << "' of size: " << arraySize << " starting at memIndex " << currentMemoryIndex;

    variablesMap[name] = currentMemoryIndex; // the beggining of an array
    initializedVariablesMap[name] = true;
    arraysMap[name] = arraySize;
    currentMemoryIndex += arraySize - 1; //without the first one
    displayArraySizesMap(&arraysMap);
    std::cout << " and ending at " << currentMemoryIndex << "\n";
  } else {
    std::cout << "Array " << name << " already defined!" << "\n";
  }
}

bool isVariableDeclared(std::map<std::string, int> *mapToSearch, std::string name) {
  if ( (*mapToSearch).find(name) == (*mapToSearch).end() ) {
    // not found
    return false;
  } else {
    // found
    return true;
  }
}

void showAllocatedMemoryIndexes() {
  for (int i = 0; i < 10; i++) {
    std::cout << "index: " << i << " allocated for computing variables\n";
  }
  std::cout << "###################\n\n\n\n";
}

void finish() {
  //std::cout << "number of variables + tokens = " << variablesMap.size() << "\n";
  // displayMap(&variablesMap);
  pushCode("HALT");
  displayCommandVector(&commandsVector);
}

void displayMap(std::map<std::string, int>* mapToDisplay) {
  for(auto elem : *mapToDisplay) {
     std::cout << elem.first << " " << elem.second << "\n";
  }
}

void displayInitializedMap(std::map<std::string, bool>* map) {
  for(auto elem : *map) {
     std::cout << elem.first << " " << elem.second << "\n";
  }
}

bool isVariableInitialized(std::map<std::string, bool>* initializedMap, std::string variableName) {
  // mozna w sumie przerobic
  if ( (*initializedMap).find(variableName) == (*initializedMap).end() ) { // not found
    return false;
  } else { // found
    if ((*initializedMap)[variableName] == true) { //initialized
      return true;
    } else { // not initialized
      return false;
    }
  }
}

void displayCommandVector(std::vector<std::string> *commands) {
  int vectorSize = commands->size();
  for (int i=0; i < vectorSize; i++) {
    std::cout << commands->at(i) << "\n";
  }
}

/*===================================================*/
/*                 GENERATING CODE                   */
/*===================================================*/

void pushCode(std::string opCode) {
  commandsVector.push_back(opCode);
}

void pushCodeWithAddress(std::string opCode, int number) {
  std::string space = " ";
  std::string whole = opCode + space + std::to_string(number);
  commandsVector.push_back(whole);
}

void generateNumber(std::string number) {

  // std::string space = " ";
  // std::string whole = "GENERATING NUMBER:" + space + number;
  // commandsVector.push_back(whole);



  /*  ZAPISANIE liczby W PAMIĘCI
    1) wyzerowanie akumulatora
    2) wygenerowanie liczby (w akumulatorze)
    3) znalezenie komorki do ktorej mamy to zapisac - [x]
    4) STORE [x]
  */
  int no = atoi(number);
  std::cout << "DEC: " << <<
  std::string bin = std::bitset<8>(128).to_string(); //to binary
  std::cout<<binary<<"\n";
  int limit = strlen(bin);
  int i;
  pushCode("ZERO");

  for(i = 0; i < limit; ++i) {
    if(bin[i] == '1') {
      pushCode("INC");
    }

    if(i < (limit - 1)) {
      pushCode("SHL");
    }
  }

  free(bin);

}

/*===================================================*/
/*                     STRUCTURES                    */
/*===================================================*/

void freeAll() {

}

int main() {
  yyparse();
  return 0;
}

void yyerror (char *msg) {
    printf("ERROR\n");
}
backu
